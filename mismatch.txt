
Output of the picnic3_dev branch, for the test LowMC_test_vector_129_129_4_1. 
(I added some debugging code to print mzd)

gregz@gregz-linux:~/work/pq-sigs-src/build$ ./tests/lowmc_test
plaintext: ABFF000000000000000000000000000000
key: 8000000000000000000000000000000000
state0: F4299CCBD2B322FB3824D9FCD068F31400
state: 162354D6F2B6706A54C8073AEFBA32C000
state: 310AF067344AA9C8EA001DD3DB9E249600
state: 9DD540835FE85DD32D4B2508C5F0247C00
state: 2FD7D5425EE35E667C972F12FB153E9D80
ciphertext: 2FD7D5425EE35E667C972F12FB153E9D80


Output of the LowMC reference implementation, for the same key and plaintext.
Test.cpp is below, and the part of LowMC.h with the params.

gregz@gregz-linux:~/work/lowmc$ make
g++ -g -c LowMC.cpp 
g++ -g test.cpp LowMC.o -o test
gregz@gregz-linux:~/work/lowmc$ ./test 
Key:
100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
8000000000000000000000000000000000
Plaintext:
101010111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
ABFF000000000000000000000000000000
Ciphertext:
010101011010111110110011011000111100101100110110000011100000101010010101100011010010011111010011110101110100111101011101101110111
55AFB363CB360E0A958D27D3D74F5DBB00
Encryption followed by decryption of plaintext:
101010111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
ABFF000000000000000000000000000000





#include "LowMC.h"
#include <iostream>
#include <stdio.h>

//////////////////
//     MAIN     //
//////////////////


void printHex(block b)
{
    size_t rem = b.size() % 8;

    for(size_t i = b.size(); i >= 8; i-=8) {
        unsigned int x = b[i-1]*128 + b[i-2]*64 + b[i-3]*32 + b[i-4]*16 + b[i-5]*8 + b[i-6]*4 + b[i-7]*2 + b[i-8] ;
        printf("%02X", x);
    }

    unsigned int x = 0;
    for(size_t i = 0; i < rem; i++) {
        x += b[i] * (i << (7-i));
    }
    printf("%02X", x);
    printf("\n");

}

int main () {
    // Example usage of the LowMC class
    // Instantiate a LowMC cipher instance called cipher using the key '1'.
    
    std::string keystr("1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    std::bitset<129> key(keystr, 0, 129);
    LowMC cipher(key);
    std::cout << "Key:" << std::endl;
    std::cout << key << std::endl;
    printHex(key);

    std::string plaintext_str("1010101111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    std::bitset<129> plaintext(plaintext_str, 0, 129);
    block m = plaintext;
    
    std::cout << "Plaintext:" << std::endl;
    std::cout << m << std::endl;
    printHex(m);
    m = cipher.encrypt( m );
    std::cout << "Ciphertext:" << std::endl;
    std::cout << m << std::endl;
    printHex(m);
    m = cipher.decrypt( m );
    std::cout << "Encryption followed by decryption of plaintext:" << std::endl;
    std::cout << m << std::endl;
    printHex(m);
   
    return 0;
}




#ifndef __LowMC_h__
#define __LowMC_h__

#include <bitset>
#include <vector>
#include <string>

const unsigned numofboxes = 43;    // Number of Sboxes
const unsigned blocksize = 129;   // Block size in bits
const unsigned keysize = 129; // Key size in bits
const unsigned rounds = 4; // Number of rounds

const unsigned identitysize = blocksize - 3*numofboxes;
                  // Size of the identity part in the Sbox layer

typedef std::bitset<blocksize> block; // Store messages and states
typedef std::bitset<keysize> keyblock;

// snip





gregz@gregz-linux:~/work/lowmc$ more hex2bin.pl
#!/usr/bin/env perl
use strict;
use warnings;

my @octets = ($ARGV[0] =~ /../g);

print "Input: $ARGV[0]\n";
print "Length: " . length($ARGV[0]) . "\n";
if((length($ARGV[0]) % 2) != 0) {
    die "input must have even length";
}
my $binary = "";
foreach my $octet (@octets) {
    my $int = hex($octet);
    $binary .= sprintf("%08b", $int);
}




print "Binary: $binary\n";
print "Bit length: " . length($binary) . " bits\n";

gregz@gregz-linux:~/work/lowmc$ more bin2hex.pl
#!/usr/bin/env perl
use strict;
use warnings;

my @octets = ($ARGV[0] =~ /......../g);

print "Input: $ARGV[0]\n";
print "Length: " . length($ARGV[0]) . " bits\n";
#if((length($ARGV[0]) % 2) != 0) {
#    die "input must have even length";
#}
my $hex = "";
foreach my $octet (@octets) {
    my $int = oct("0b$octet");
    $hex .= sprintf("%02X", $int);
}

print "Hex: $hex\n";
print "Bit length: " . (length($hex)/2)*8 . " bits\n";








diff --git a/io.c b/io.c
index 3ce6d3b..c6c0971 100644
--- a/io.c
+++ b/io.c
@@ -54,4 +54,22 @@ void print_hex(FILE* out, const uint8_t* data, size_t len) {
     fprintf(out, "%02X", *data);
   }
 }
+
+#define MAX_PRINT_MZD 500
+void print_mzd(char* label, const mzd_local_t* data, size_t numbytes)
+{
+    printf("%s", label);
+    if(numbytes > MAX_PRINT_MZD) {
+        printf(" (truncated): ");
+    }
+    else {
+        printf(": ");
+    }
+
+    uint8_t bytes_out[MAX_PRINT_MZD];
+    mzd_to_char_array(bytes_out, data, numbytes);
+    print_hex(stdout, bytes_out, numbytes);
+    printf("\n");
+}
+
 #endif
diff --git a/io.h b/io.h
index 6b10bb1..e5fc792 100644
--- a/io.h
+++ b/io.h
@@ -23,6 +23,7 @@ void setBit(uint8_t* bytes, size_t bitNumber, uint8_t val);

 #if defined(PICNIC_STATIC) || !defined(NDEBUG)
 void print_hex(FILE* out, const uint8_t* data, size_t len);
+void print_mzd(char* label, const mzd_local_t* data, size_t numbytes);
 #endif

 #endif
diff --git a/lowmc_impl.c.i b/lowmc_impl.c.i
index 28301e4..a6cb315 100644
--- a/lowmc_impl.c.i
+++ b/lowmc_impl.c.i
@@ -19,9 +19,16 @@ static void N_LOWMC(lowmc_key_t const* lowmc_key, mzd_local_t const* p, mzd_loca
   mzd_local_t x[((LOWMC_N) + 255) / 256];
   mzd_local_t y[((LOWMC_N) + 255) / 256];

+
+  size_t stateSizeBytes = (LOWMC_N + 7)/8;
+    print_mzd("plaintext", p, stateSizeBytes);
+    print_mzd("key", lowmc_key, stateSizeBytes);
+
   COPY(x, p);
   ADDMUL(x, lowmc_key, LOWMC_INSTANCE.k0_matrix);

+  print_mzd("state0", x, stateSizeBytes);
+
   lowmc_round_t const* round = LOWMC_INSTANCE.rounds;
   for (unsigned i = 0; i < LOWMC_R; ++i, ++round) {
 #if defined(RECORD_STATE)
@@ -32,13 +39,18 @@ static void N_LOWMC(lowmc_key_t const* lowmc_key, mzd_local_t const* p, mzd_loca
     MUL(y, x, round->l_matrix);
     XOR(x, y, round->constant);
     ADDMUL(x, lowmc_key, round->k_matrix);
+    print_mzd("state", x, stateSizeBytes);
   }

 #if defined(RECORD_STATE)
   COPY(state->state[LOWMC_R], x);
+    print_mzd("ciphertext", state->state[LOWMC_R], stateSizeBytes);
 #else
   COPY(c, x);
+    print_mzd("ciphertext", c, stateSizeBytes);
 #endif
+
+

